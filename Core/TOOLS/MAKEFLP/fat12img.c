#include"fat12img.h"
#include<ctype.h>
#include<memory.h>
#include<string.h>
#include<time.h>
#include<sys/timeb.h>
#include<windows.h>

BYTE	g_bDefaultDBR[FLOPPY_BYTES_PER_SEC]=
{
	0xEB,0x3C,0x90,'M', 'S', 'D', 'O', 'S', '5', '.', '0', 0x00,0x02,0x01,0x01,0x00,
	0x02,0xE0,0x00,0x40,0x0B,0xF0,0x09,0x00,0x12,0x00,0x02,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x29,0xE1,0x6C,0x87,0x2A,0x20,0x20,0x20,0x20,0x20,
	0x20,0x20,0x20,0x20,0x20,0x20,0x46,0x41,0x54,0x31,0x32,0x20,0x20,0x20,0x33,0xC9,
	0x8E,0xD1,0xBC,0xFC,0x7B,0x16,0x07,0xBD,0x78,0x00,0xC5,0x76,0x00,0x1E,0x56,0x16,
	0x55,0xBF,0x22,0x05,0x89,0x7E,0x00,0x89,0x4E,0x02,0xB1,0x0B,0xFC,0xF3,0xA4,0x06,
	0x1F,0xBD,0x00,0x7C,0xC6,0x45,0xFE,0x0F,0x38,0x4E,0x24,0x7D,0x20,0x8B,0xC1,0x99,
	0xE8,0x7E,0x01,0x83,0xEB,0x3A,0x66,0xA1,0x1C,0x7C,0x66,0x3B,0x07,0x8A,0x57,0xFC,
	0x75,0x06,0x80,0xCA,0x02,0x88,0x56,0x02,0x80,0xC3,0x10,0x73,0xED,0x33,0xC9,0xFE,
	0x06,0xD8,0x7D,0x8A,0x46,0x10,0x98,0xF7,0x66,0x16,0x03,0x46,0x1C,0x13,0x56,0x1E,
	0x03,0x46,0x0E,0x13,0xD1,0x8B,0x76,0x11,0x60,0x89,0x46,0xFC,0x89,0x56,0xFE,0xB8,
	0x20,0x00,0xF7,0xE6,0x8B,0x5E,0x0B,0x03,0xC3,0x48,0xF7,0xF3,0x01,0x46,0xFC,0x11,
	0x4E,0xFE,0x61,0xBF,0x00,0x07,0xE8,0x28,0x01,0x72,0x3E,0x38,0x2D,0x74,0x17,0x60,
	0xB1,0x0B,0xBE,0xD8,0x7D,0xF3,0xA6,0x61,0x74,0x3D,0x4E,0x74,0x09,0x83,0xC7,0x20,
	0x3B,0xFB,0x72,0xE7,0xEB,0xDD,0xFE,0x0E,0xD8,0x7D,0x7B,0xA7,0xBE,0x7F,0x7D,0xAC,
	0x98,0x03,0xF0,0xAC,0x98,0x40,0x74,0x0C,0x48,0x74,0x13,0xB4,0x0E,0xBB,0x07,0x00,
	0xCD,0x10,0xEB,0xEF,0xBE,0x82,0x7D,0xEB,0xE6,0xBE,0x80,0x7D,0xEB,0xE1,0xCD,0x16,
	0x5E,0x1F,0x66,0x8F,0x04,0xCD,0x19,0xBE,0x81,0x7D,0x8B,0x7D,0x1A,0x8D,0x45,0xFE,
	0x8A,0x4E,0x0D,0xF7,0xE1,0x03,0x46,0xFC,0x13,0x56,0xFE,0xB1,0x04,0xE8,0xC2,0x00,
	0x72,0xD7,0xEA,0x00,0x02,0x70,0x00,0x52,0x50,0x06,0x53,0x6A,0x01,0x6A,0x10,0x91,
	0x8B,0x46,0x18,0xA2,0x26,0x05,0x96,0x92,0x33,0xD2,0xF7,0xF6,0x91,0xF7,0xF6,0x42,
	0x87,0xCA,0xF7,0x76,0x1A,0x8A,0xF2,0x8A,0xE8,0xC0,0xCC,0x02,0x0A,0xCC,0xB8,0x01,
	0x02,0x80,0x7E,0x02,0x0E,0x75,0x04,0xB4,0x42,0x8B,0xF4,0x8A,0x56,0x24,0xCD,0x13,
	0x61,0x61,0x72,0x0A,0x40,0x75,0x01,0x42,0x03,0x5E,0x0B,0x49,0x75,0x77,0xC3,0x03,
	0x18,0x01,0x27,0x0D,0x0A,0x49,0x6E,0x76,0x61,0x6C,0x69,0x64,0x20,0x73,0x79,0x73,
	0x74,0x65,0x6D,0x20,0x64,0x69,0x73,0x6B,0xFF,0x0D,0x0A,0x44,0x69,0x73,0x6B,0x20,
	0x49,0x2F,0x4F,0x20,0x65,0x72,0x72,0x6F,0x72,0xFF,0x0D,0x0A,0x52,0x65,0x70,0x6C,
	0x61,0x63,0x65,0x20,0x74,0x68,0x65,0x20,0x64,0x69,0x73,0x6B,0x2C,0x20,0x61,0x6E,
	0x64,0x20,0x74,0x68,0x65,0x6E,0x20,0x70,0x72,0x65,0x73,0x73,0x20,0x61,0x6E,0x79,
	0x20,0x6B,0x65,0x79,0x0D,0x0A,0x00,0x00,0x49,0x4F,0x20,0x20,0x20,0x20,0x20,0x20,
	0x53,0x59,0x53,0x4D,0x53,0x44,0x4F,0x53,0x20,0x20,0x20,0x53,0x59,0x53,0x7F,0x01,
	0x00,0x41,0xBB,0x00,0x07,0x60,0x66,0x6A,0x00,0xE9,0x3B,0xFF,0x00,0x00,0x55,0xAA
};
BYTE		g_bFAT12[FLOPPY_SECS_PER_FAT*FLOPPY_BYTES_PER_SEC]={0};
FAT_DIRITEM	g_RootDirs[FLOPPY_MAX_ROOT];
BYTE		g_bDataArea
[
	FLOPPY_SIZE-
	(FLOPPY_DBR_SECS+
	FLOPPY_FAT_SECS*FLOPPY_FAT_COUNT+
	FLOPPY_ROOT_SECS)
	*FLOPPY_BYTES_PER_SEC
];

//-----------------------------------------------------------------------------
//NewFAT12：初始化FAT12的FAT表
//-----------------------------------------------------------------------------
void NewFAT12()
{
	memset(g_bFAT12,0,sizeof(g_bFAT12));
	WriteFAT12Item(0,MEDIA_FDD|0xF00);
	WriteFAT12Item(1,0xFFF);
}

//-----------------------------------------------------------------------------
//NewRoot：初始化FAT12的根目录表
//-----------------------------------------------------------------------------
void NewRoot()
{
	memset(g_RootDirs,0,sizeof(g_RootDirs));
}

//-----------------------------------------------------------------------------
//NewData：初始化FAT12的数据区（也就是全部清空）
//-----------------------------------------------------------------------------
void NewData()
{
	memset(g_bDataArea,0,sizeof(g_bDataArea));
}

//-----------------------------------------------------------------------------
//ReadFAT12Item：读取FAT12的FAT表的表项
//-----------------------------------------------------------------------------
WORD ReadFAT12Item(WORD wIndex)
{
/*
	FAT12表：
	字节：0 1 2 3 4 5 6 7 8
	索引： 0 1   2 3   4 5
*/
	UINT uPos;
	WORD wVal;
	uPos=(UINT)(wIndex>>1)+(UINT)wIndex;
	wVal=*(WORD*)(&g_bFAT12[uPos]);
	if(wIndex&1)
		return wVal>>4;
	else
		return wVal&0xFFF;
}

//-----------------------------------------------------------------------------
//WriteFAT12Item：写入FAT12的FAT表的表项
//-----------------------------------------------------------------------------
void WriteFAT12Item(WORD wIndex,WORD wValue)
{
	UINT uPos;
	WORD wVal;
	uPos=(UINT)(wIndex>>1)+(UINT)wIndex;
	wVal=*(WORD*)(&g_bFAT12[uPos]);
	*(WORD*)(&g_bFAT12[uPos])=
		(wIndex&1)?
			(wVal&0xF)|(wValue<<4):
			(wVal&0xF000)|wValue;
}

//-----------------------------------------------------------------------------
//FindFreeClus：寻找空闲簇号
//-----------------------------------------------------------------------------
WORD FindFreeClus()
{
	WORD i;
	for(i=FLOPPY_CLUS_MIN;i<=FLOPPY_CLUS_MAX;i++)
	{
		if(!ReadFAT12Item(i))//找到空闲簇号则返回
			return i;
	}
	return 0;
}

//-----------------------------------------------------------------------------
//FindFreeRootItem：寻找空闲根目录项
//-----------------------------------------------------------------------------
FAT_DIRITEM* FindFreeRootItem()
{
	WORD i;
	for(i=0;i<FLOPPY_MAX_ROOT;i++)
	{
		if(	g_RootDirs[i].szFileName[0]==DIRITEM_FREE||
			g_RootDirs[i].szFileName[0]==DIRITEM_DELETED||
			g_RootDirs[i].szFileName[0]==DIRITEM_DELETED_JPN)
		return &g_RootDirs[i];
	}
	return NULL;
}

//-----------------------------------------------------------------------------
//FindFreeDirItem：寻找空闲目录项
//-----------------------------------------------------------------------------
FAT_DIRITEM* FindFreeDirItem(WORD wDirClus)
{
	WORD i;
	FAT_DIRITEM* pDir;
	while(	wDirClus>=FLOPPY_CLUS_MIN&&
			wDirClus<=FLOPPY_CLUS_MAX)
	{
		pDir=(FAT_DIRITEM*)GetClusterPtr(wDirClus);	//取得目录的指针
		if(!pDir)
			return NULL;
		for(i=0;i<16;i++)							//从目录中找空闲目录项
		{
			if(	pDir[i].szFileName[0]==DIRITEM_FREE||
				pDir[i].szFileName[0]==DIRITEM_DELETED||
				pDir[i].szFileName[0]==DIRITEM_DELETED_JPN)
			return &pDir[i];						//找到则返回
		}
		wDirClus=ReadFAT12Item(wDirClus);			//否则从簇链找到下一个目录块的位置继续找
	}
	return NULL;
}

//-----------------------------------------------------------------------------
//GetClusterPtr：取得簇在数据区对应簇号的指针
//-----------------------------------------------------------------------------
void* GetClusterPtr(WORD wCluster)
{
	if(	wCluster>=FLOPPY_CLUS_MIN&&
		wCluster<=FLOPPY_CLUS_MAX)
		return (void*)&g_bDataArea[(wCluster-FLOPPY_CLUS_MIN)*FLOPPY_BYTES_PER_SEC];
	else
		return NULL;
}

//-----------------------------------------------------------------------------
//ShortNameCheckSum：取得短文件名的校验和，用于长文件名目录项
//-----------------------------------------------------------------------------
BYTE ShortNameCheckSum(BYTE *pFileName8_3)
{
	unsigned	FcbNameLen=11;
	BYTE		Sum=0;
	while(FcbNameLen--)
		Sum=((Sum&1)?0x80:0)+(Sum>>1)+*pFileName8_3++;
	return Sum;
}

//-----------------------------------------------------------------------------
//GenShortName：生成一个基本的短文件名
//-----------------------------------------------------------------------------
BOOL GenShortName(char *szLongName,WCHAR *wLongNameOut,char *szShortOut,char *szExtOut)
{
	WCHAR	*pChr;
	UINT	uChar,uChars;
	//先把长文件名转换成UNICODE
	if(!MultiByteToWideChar(CP_ACP,MB_COMPOSITE,szLongName,-1,wLongNameOut,DIRITEM_LONGNAMELEN))
		return FALSE;
	//去掉前面的空格
	pChr=wLongNameOut;
	while(*pChr==L' ')
		pChr++;
	wcscpy(wLongNameOut,pChr);
	//去掉后面的空格
	pChr=&wLongNameOut[wcslen(wLongNameOut)-1];
	while(*pChr==L' ')
		pChr--;
	pChr[1]=L'\0';
	//处理扩展名
	szExtOut[0]=szExtOut[1]=szExtOut[2]=' ';//先把输出扩展名设置为3空格
	pChr=wcsrchr(wLongNameOut,L'.');//找原来文件名中的句点
	if(pChr++)//如果找到句点
	{//作为扩展名的三个字符，如果是非法字符（比如汉字）则显示用字符_代替
		szExtOut++=(VALIDWCHR(*pChr))?(char)*pChr++:'_';
		szExtOut++=(VALIDWCHR(*pChr))?(char)*pChr++:'_';
		szExtOut++=(VALIDWCHR(*pChr))?(char)*pChr++:'_';
	}
	for(uChar=0,uChars=pChr
}

//-----------------------------------------------------------------------------
//RootCreateItem：从根目录区创建目录项
//-----------------------------------------------------------------------------
FAT_DIRITEM* RootCreateItem(char *szFile,BYTE bAttr)
{
	FAT_DIRITEM* pIdle;
	pIdle=FindFreeRootItem();
	if(!pIdle)
		return NULL;
	
}
